# DB-优化

[TOC]

## 1. Oracle SQL优化

- ==选择最高效的表名顺序==

DB的解析器**从右到左**顺序处理`FROM`子句中的表名。

3个表毫无关系：记录和列名最少的表写最后。

3个表以上的连接查询：引用最多的表放在最后。

- ==where子句中的连接顺序==

**从右向左**解析where子句。表之间的连接靠左（=），可以过滤大量记录的条件靠右写。

- ==select子句中避免使用*号==

*可以获得全部属性数据（完整的一行），**但要通过查询数据字典完成，耗费大量时间**。

- ==truncate替代delete==

删除整个表的内容，保留表结构时，首选truncate，delete慢。

- ==使用内部函数提高SQL效率==

**例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。**

- ==善用索引==

当表非常大时（记录量大），使用索引。

- ==写大写==

- ==避免在索引列上使用计算==

WHERE子句中，**如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢**

- ==用`>=`替代`>`==

比如`where num > 3`和`where num >= 4`。==？？？？？==

- ==用IN替代OR==
- ==where中使用索引的第一个列查询==

如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引。

```sql
create index emp_sal_job_idex
on emp(sal,job);
----------------------------------
select *
from emp  
where job != 'SALES';    

上边就不使用索引了。
```



## 2. 结构优化

- 范式优化：消除冗余（节省空间）
- 反范式优化：适当增加冗余（减少表连接）
- 拆分表：垂直拆分，水平拆分






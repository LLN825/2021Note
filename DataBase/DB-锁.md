# DB-锁

[TOC]

## 1. 事务的四大特性-ACID

- 原子性（A）：事务内所有操作为一个整体，要么全做，要么全不做。
- 一致性（C）：事务执行前后，数据库从一个正确的状态转换到另一个正确的状态。
- 隔离性（I）：并发事务之间相互独立，不互相影响。
- 持久性（D）：事务提交后，对数据库的改变是持久的。

### 1.1 ACID特性如何实现



## 2. 事务隔离级别

### 2.1 并发事务可能造成的问题

- 脏读：A读数据，并修改，还未提交事务。B读数据，此时B读到的是“脏数据”。
- 丢失修改：A读数据，修改，还未提交。B读数据，修改。A提交，B提交。则A的修改丢失了。
- 不可重复读：A读数据，A的事务还没结束，B修改，A在事务内再次读，与第一次读的值不相同。
- 幻读：A读数据，B新增几行数据，A再次读时发现第一次不存在的数据。

不可重复读的重点是修改，幻读的重点在于新增或者删除。

### 2.2 事务隔离级别

**SQL 标准定义了四个隔离级别：**

| 隔离级别                       | 脏读 | 不可重复读 | 幻影读 |
| ------------------------------ | ---- | ---------- | ------ |
| READ-UNCOMMITTED（读取未提交） | √    | √          | √      |
| READ-COMMITTED（读取已提交）   | ×    | √          | √      |
| REPEATABLE-READ（可重复读）    | ×    | ×          | √      |
| SERIALIZABLE（串行化）         | ×    | ×          | ×      |

隔离级别越低，事务请求的锁越少。InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）。







## 4. InnoDB锁

### 4.1 InnoDB锁类型

<img src="./img/1.png" alt="image-20210312202330733" style="zoom: 67%;" />

**行锁**：

- 共享锁（S）
- 排他锁（X）

**页锁**：

**表锁**：

- 意向共享锁（IS）：事务打算给行**加行共享锁**，加S之前**先取得该表的IS**。
- 意向排他锁（IX）：事务打算给行**加行排他锁**，加X之前**先取得该表的IX**。

> 由于InnoDB支持的是行级别锁，因此意向锁不会阻塞除全表扫描外的任何请求。==？==

InnoDB中锁的兼容性：==？==

|        | **IS** | **IX** | **S** | **X** |
| :----: | :----: | :----: | :---: | :---: |
| **IS** |   √    |   √    |   √   |   ×   |
| **IX** |   √    |   √    |   ×   |   ×   |
| **S**  |   √    |   ×    |   √   |   ×   |
| **X**  |   ×    |   ×    |   ×   |   ×   |



### 4.2 一致性非锁定读（快照读）

通过多版本并发控制机制（MVCC），如果要读取的行正在执行delete或update操作（比如别的事务对该数据加了X锁），这时**读取操作不会等待行上的锁释放，会去读取快照数据**。读取快照数据不需要上锁，因为不需要对历史数据进行修改。

InnoDB默认是快照读的方式，但不同事务隔离级别中，对于快照的定义各不相同。

在事务隔离级别`READ COMMITTED(读取已提交)`和`REPEATABLE READ(可重复读)`下，InnoDB采用快照读：

- READ COMMITTED：快照读总是读取被锁定行的最新一份快照。
- REPEATABLE READ：快照读总是读取事务开始时的行数据版本。

比如下图，如果A的隔离级别是READ COMMITTED，时间7时的查询结果是空。如果A的隔离级别是REPEATABLE READ，时间7的查询结果和时间2一致。

> 对于READ COMMITTED，从数据库理论角度，其实违反了隔离性。

<img src="./img/2.jpg" alt="image-20210312204808244" style="zoom:67%;" />

### 4.3 一致性锁定读（锁定读/当前读）

**锁定读：**读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至事务释放锁。

```sql
select ... for update
select ... lock in share mode
```

第一行SQL语句对行记录加X锁，第二行对记录加S锁。

### 4.4 自增长与锁

自增长是表自动添加的一列属性，是开发中常用的主键方式。InnoDB中，对每个含有自增长值得表都有一个自增长计数器。插入操作，计数器+1，赋值自增长序列，这个方式叫**AUTO-INC Locking**。

该方式的锁是一种特殊的表锁机制，为提高插入性能，锁不是在事务完成后释放，而是在完成插入的SQL语句后立刻释放。AUTO-INC Locking提高了并发插入的效率，但事务仍必须等前一个插入的完成。

MySQL5.1.22版本后，**InnoDB提供轻量级互斥量的自增长实现机制，大大提高了自增长值得插入性能。**配置参数采用不同锁机制：

<img src="./img/3.jpg" alt="image-20210312211445972" style="zoom: 50%;" />



### 4.4 锁的算法

#### 4.4.1 行锁的3种算法

##### Record Lock

单个行记录上的锁。锁住索引记录。

> 如果InnoDB表在建立的时候没有设置任何索引，InnoDB会使用隐式的主键来进行锁定。==？==

##### Gap Lock

间隙锁，锁定一个范围，但不包含记录本身。Gap Lock的作用是阻止多个事务将记录插入到同一范围内，但这会导致幻象问题。

关闭Gap Lock的显式方法：

- 事务隔离级别设置为READ COMMITTED
- 将参数innodb_locks_unsafe_for_binlog设置为1

##### Next-Key Lock

Gap+Record。锁定一个范围，并锁定记录本身。**InnoDB对于行的查询都采用Next-Key Lock。Next-Key Lock可以解决幻象问题。**

**当查询的索引含有所有唯一索引时，InnoDB会将Next-Key Lock优化降级为Record Lock，提高了应用并发性。若唯一索引由多个列组成，查询仅是多个唯一索引的其中一个，该查询是range查询，不是point查询，依然用Next-Key Lock**

特别注意：对于辅助索引，Next-Key Lock锁定查询条件的范围后，还会对该辅助索引的下一个值加Gap Lock。（书上有很详细的例子）

#### 4.4.2 幻象问题





## **5. MVCC机制**



## **6. 乐观锁和悲观锁**
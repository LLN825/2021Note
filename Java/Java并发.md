## Java并发基础篇

重点难点，加油！！！

### 1 进程和线程

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。

一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。

**进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。**

#### 1.1 进程和线程的区别

本质的区别是**是否单独占有内存地址空间及其它系统资源（比如I/O）**

- 进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。
- 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。
- 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。
- **进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位**，即CPU分配时间的单位 

### 2 Java多线程入门类和接口

实现线程类，两种方式：

- **继承`Thread`类，并重写`run`方法。**在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。

- **实现`Runnable`接口的`run`方法。**==可以使用Java8的函数式编程简化代码。==

`Thread`类是一个`Runnable`接口的实现类。

#### 2.1 Thread类常用方法

`currentThread()`：静态方法，返回对当前正在执行的线程对象的引用；

`start()`：开始执行线程的方法，Java虚拟机会调用线程内的run()方法；

`yield()`：当前线程愿意让出对当前处理器的占用。需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；

`sleep()`：静态方法，使当前线程睡眠一段时间；

`join()`：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；

#### 2.2 继承Thread还是实现Runnable

- 由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。

- Runnable接口出现更符合面向对象，将线程单独进行对象的封装。

- Runnable接口出现，降低了线程对象和线程任务的耦合性。

- 如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。

### 3 Callable、Future与FutureTask